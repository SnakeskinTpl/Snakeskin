/*!
 * @status stable
 * @version 1.0.0
 */

/**
 * Если true, то значит объявляется прототип
 * @type {boolean}
 */
DirObj.prototype.protoStart = false;

Snakeskin.addDirective(
	'proto',

	{
		isSys: true
	},

	function (command) {
		var name = command.match(/[^(]+/)[0];

		this.startDir(null, {
			name: name,
			startI: this.i + 1
		});

		var args = command.match(/\((.*?)\)/),
			argsMap = [];

		if (args) {
			args = args[1].split(',');
			for (let i = 0; i < args.length; i++) {
				let arg = args[i].split('=');
				arg[0] = this.declVar(arg[0].trim());
				argsMap.push(arg);
			}
		}

		if (this.isAdvTest()) {
			// Попытка декларировать прототип блока несколько раз
			if (protoCache[this.tplName][name]) {
				throw this.error('Proto "' + name + '" is already defined');
			}

			protoCache[this.tplName][name] = {
				from: this.i - this.startI + 1,
				args: argsMap
			};
		}

		if (!this.parentTplName) {
			this.protoStart = true;
		}
	},

	function (command, commandLength) {
		var tplName = this.tplName,
			lastProto = this.structure.params;

		var proto = protoCache[tplName][lastProto.name];

		if (this.isAdvTest()) {
			proto.to = this.i - this.startI - commandLength - 1;
			fromProtoCache[tplName] = this.i - this.startI + 1;
		}

		// Рекурсивно анализируем прототипы блоков
		if (!this.parentTplName) {
			proto.body = Snakeskin.compile(
				'{template ' + tplName + '()}' +
					this.source.substring(lastProto.startI, this.i - commandLength - 1) +
				'{end}',

				null,
				null,
				true,

				{
					scope: this.scope,
					vars: this.structure.vars
				}
			);
		}

		let bacs = this.backHash[lastProto.name];
		if (bacs && !bacs.protoStart) {
			let args = proto.args;

			for (let i = 0; i < bacs.length; i++) {
				let el = bacs[i];

				let params = el.args,
					paramsStr = '';

				for (let j = 0; i < args.length; j++) {
					paramsStr += 'var ' + args[i] + ' = ' + params[i] + ';';
				}

				this.replace(
					this.res.substring(0, el.pos) +
					paramsStr +
					protoCache[tplName][lastProto.name].body +
					this.res.substring(el.pos)
				);
			}

			delete this.backHash[lastProto.name];
			this.backHashI--;
		}

		if (!this.hasParent('proto')) {
			this.protoStart = false;
		}
	}
);

DirObj.prototype.backHash = {
	init: function () {
		return {};
	}
};

/**
 * Количество обратных вызовов прототипа
 * (когда apply до декларации вызываемого прототипа)
 * @type {number}
 */
DirObj.prototype.backHashI = 0;

/**
 * Имя последнего обратного прототипа
 * @type {?string}
 */
DirObj.prototype.lastBack = null;

Snakeskin.addDirective(
	'apply',

	{
		inBlock: true
	},

	function (command) {
		var name = command.match(/[^(]+/)[0];
		this.startInlineDir();

		var args = command.match(/\((.*?)\)/);
		if (args) {
			args = args[1].split(',');

		} else {
			args = [];
		}

		if (!this.parentTplName && !this.hasParent('proto')) {
			// Попытка применить не объявленный прототип
			// (запоминаем место вызова, чтобы вернуться к нему,
			// когда прототип будет объявлен)
			if (!protoCache[this.tplName][name]) {
				if (!this.backHash[name]) {
					this.backHash[name] = [];
					this.backHash[name].protoStart = this.protoStart;

					this.lastBack = name;
					this.backHashI++;
				}

				this.backHash[name].push({
					pos: this.res.length,
					args: args
				});

			} else {
				let proto = protoCache[this.tplName][name];
				let protoArgs = proto.args;

				for (let i = 0; i < protoArgs.length; i++) {
					args[i] = args[i] || null;

					let arg = protoArgs[i][0];
					let def = protoArgs[i][1];

					this.save('var ' + arg + ' = ' +
						(def !== void 0 ?
							args[i] ?
								'typeof ' + args[i] + ' !== \'undefined\' && ' +
									args[i] + ' !== null ? ' +
									args[i] +
									':' +
									def :
								def :
							args[i] || 'void 0'
						) + ';'
					);
				}

				this.save(proto.body);
			}
		}
	}
);