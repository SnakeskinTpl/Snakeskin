/**!
 * @status stable
 * @version 1.0.0
 */

var blackWordList = {
	'break': true,
	'case': true,
	'catch': true,
	'continue': true,
	'delete': true,
	'do': true,
	'else': true,
	'false': true,
	'finnaly': true,
	'for': true,
	'function': true,
	'if': true,
	'in': true,
	'instanceof': true,
	'new': true,
	'null': true,
	'return': true,
	'switch': true,
	'this': true,
	'throw': true,
	'true': true,
	'try': true,
	'typeof': true,
	'var': true,
	'void': true,
	'while': true,
	'with': true,
	'class': true,
	'let': true,
	'const': true,
	'debugger': true,
	'interface': true
};

var unaryBlackWordList = {
	'new': true
};

var comboBlackWordList = {
	'var': true,
	'let': true,
	'const': true
};

/**
 * Заменить ${...} в строке на значение вывода
 *
 * @param {string} str - исходная строка
 * @return {string}
 */
DirObj.prototype.replaceTplVars = function (str) {
	str = this.pasteDangerBlocks(str);
	var begin = 0,
		dir;

	var escape = false,
		comment;

	var bOpen,
		bEnd = true,
		bEscape = false;

	var res = '';
	for (var i = 0; i < str.length; i++) {
		var el = str.charAt(i),
			next = str.charAt(i + 1);

		// Начало директивы
		if (!begin && el === '$' && next === '{') {
			begin++;
			dir = '';

			i++;
			continue;
		}

		if (!begin) {
			res += el.replace(/\\/gm, '\\\\').replace(/('|")/gm, '\\$1');
		}

		if (begin) {
			if (el === '\\' || escape) {
				escape = !escape;
			}

			// Обработка комментариев
			if (!escape) {
				if (el === '/') {
					if (next === '/' && str.charAt(i + 2) === '/') {
						comment = '///';

					} else if (next === '*') {
						comment = '/*';
						i++;

					} else if (str.charAt(i - 1) === '*') {
						comment = false;
						continue;
					}

				} else if (/[\n\v\r]/.test(el) && comment === '///') {
					comment = false;
				}
			}

			if (comment) {
				continue;
			}

			// Экранирование
			if (!bOpen) {
				if (escapeEndMap[el]) {
					bEnd = true;

				} else if (/[^\s\/]/.test(el)) {
					bEnd = false;
				}
			}

			if (escapeMap[el] && (el === '/' ? bEnd : true) && !bOpen) {
				bOpen = el;

			} else if (bOpen && (el === '\\' || bEscape)) {
				bEscape = !bEscape;

			} else if (escapeMap[el] && bOpen === el && !bEscape) {
				bOpen = false;
			}

			if (!bOpen) {
				if (el === '{') {
					begin++;

				} else if (el === '}') {
					begin--;
				}
			}

			if (begin) {
				dir += el;

			} else {
				escape = false;
				res += '\' + ' +
					this.prepareOutput(this.replaceDangerBlocks(dir)) +
				' + \'';
			}
		}
	}

	return res;
};

/**
 * Вернуть true, если предыдущий не пробельный символ в строке равен {
 *
 * @param {string} str - исходная строка
 * @param {number} pos - начальная позиция
 * @return {boolean}
 */
DirObj.prototype.isPrevSyOL = function (str, pos) {
	var rgxp = /\S/;

	for (let i = pos; i--;) {
		let el = str.charAt(i);

		if (rgxp.test(el)) {
			return el === '{';
		}
	}

	return false;
};

/**
 * Вернуть true, если следующий не пробельный символ в строке равен : или =
 *
 * @param {string} str - исходная строка
 * @param {number} pos - начальная позиция
 * @return {boolean}
 */
DirObj.prototype.isNextSyOL = function (str, pos) {
	var rgxp = /\S/;

	for (let i = pos; i < str.length; i++) {
		let el = str.charAt(i);

		if (rgxp.test(el)) {
			return el === ':' || el === '=' && str.charAt(i + 1) !== '=' && str.charAt(i - 1) !== '=';
		}
	}

	return false;
};

/**
 * Вернуть целое слово из строки, начиная с указанной позиции
 *
 * @param {string} str - исходная строка
 * @param {number} pos - начальная позиция
 * @return {{word: string, finalWord: string}}
 */
DirObj.prototype.getWord = function (str, pos) {
	var res = '',
		nres = '';

	var pCount = 0;
	var start = 0,
		pContent = null;

	var j = 0;
	var nextCharRgxp = /[@#$+\-\w\[\]().]/;

	for (let i = pos; i < str.length; i++, j++) {
		let el = str.charAt(i);

		if (pCount || nextCharRgxp.test(el) || (el === ' ' && unaryBlackWordList[res])) {
			if (pContent !== null && (pCount > 1 || (pCount === 1 && el !== ')' && el !== ']'))) {
				pContent += el;
			}

			if (el === '(' || el === '[') {
				if (pContent === null) {
					start = j + 1;
					pContent = '';
				}

				pCount++;

			} else if (el === ')' || el === ']') {
				if (pCount) {
					pCount--;

					if (!pCount && el === ']') {
						if (nres) {
							nres += '[' + this.prepareOutput(pContent, true, true) + ']';

						} else {
							nres = res.substring(0, start) +
								this.prepareOutput(pContent, true, true) +
								res.substring(j) +
							']';
						}

						pContent = null;
					}

				} else {
					break;
				}
			}

			res += el;

		} else {
			break;
		}
	}

	return {
		word: res,
		finalWord: nres ? nres : pContent ?
			res.substring(0, start) + this.prepareOutput(pContent, true) + res.substring(j - 1) : res
	};
};

/**
 * Подготовить комманду к выводу:
 * осуществляется привязка к scope и инициализация фильтров
 *
 * @param {string} command - исходная команда
 * @param {?boolean=} [opt_sys] - если true, то считается системным вызовом
 * @param {?boolean=} [opt_isys] - если true, то считается вложенным системным вызовом
 * @param {?boolean=} [opt_breakFirst] - если true, то первое слово пропускается
 * @return {string}
 */
DirObj.prototype.prepareOutput = function (command, opt_sys, opt_isys, opt_breakFirst) {
	// Скобка = (
	// Количество открытых скобок в строке
	var pCount = 0;

	// Количество открытых скобок в фильтре
	var pCountFilter = 0;

	// Массив позиций открытия и закрытия скобок,
	// идёт в порядке возрастания от вложенных к внешним блокам, например:
	// ((a + b)) => [[1, 7], [0, 8]]
	var pContent = [];

	// true, если идёт декларация фильтра
	var filterStart = false;

	// true, если идёт вложенный фильтр
	var deepFilter = false;

	// Массивы итоговых фильтров и истинных фильтров,
	// например:
	// {with foo}
	//     {bar |ucfisrt bar()|json}
	// {end}
	//
	// rvFilter => ['ucfisrt bar()', 'json']
	// filter => ['ucfisrt foo.bar()', 'json']
	var filter = [],
		rvFilter = [];

	var res = command,
		addition = 0;

	// true, то можно расчитывать слово
	var nword = !opt_breakFirst;

	// Количество слов для пропуска
	var posNWord = 0;

	// Область видимости
	var scope = this.scope,
		useWith = scope.length;

	// Сдвиги
	var wordAddEnd = 0,
		filterAddEnd = 0;

	// true, если применяется фильтр !html
	var unEscape = false;

	// Область переменных
	var vars = this.structure.childs ?
		this.structure.vars : this.structure.parent.vars;

	var globalExportRgxp = /([$\w]*)(.*)/,
		escapeRgxp = /^__ESCAPER_QUOT__\d+_/;

	var nextCharRgxp = /[@#$a-z_0-9]/i,
		newWordRgxp = /[^@#$\w\[\].]/,
		filterRgxp = /[!$a-z_]/i;

	var numRgxp = /[0-9]/,
		modRgxp = /#(?:\d+|)/,
		strongModRgxp = /#(\d+)/;

	var commandLength = command.length;
	for (let i = 0; i < commandLength; i++) {
		let el = command.charAt(i),
			next = command.charAt(i + 1),
			nnext = command.charAt(i + 2);

		let isFilter;
		let breakNum;

		if (!breakNum) {
			if (el === '(') {
				// Скобка открылась внутри декларации фильтра
				if (filterStart) {
					pCountFilter++;

				} else {
					pContent.unshift([i + wordAddEnd]);
					pCount++;
				}
			}

			// Расчёт scope:
			// флаг nword показывает, что началось новое слово;
			// флаг posNWord показывает, сколько новых слов нужно пропустить
			if (nword && !posNWord && nextCharRgxp.test(el)) {
				let nextStep = this.getWord(command, i);
				let word = nextStep.word,
					finalWord = nextStep.finalWord;

				let uadd = wordAddEnd + addition,
					vres;

				// true,
				// если полученное слово не является зарезервированным (blackWordList),
				// не является фильтром,
				// не является числом,
				// не является константой замены Escaper,
				// не является названием свойства в литерале объекта ({свойство: )
				let canParse = !blackWordList[word] &&
					!isFilter &&
					isNaN(Number(word)) &&
					!escapeRgxp.test(word) &&
					!this.isPrevSyOL(command, i) &&
					!this.isNextSyOL(command, i + word.length);

				let globalExport;

				// Экспорт числовых литералов
				if (numRgxp.test(el)) {
					vres = finalWord;

				// Экспорт глобальный и супер глобальных переменных
				} else if (el === '@') {
					if (canParse && useWith) {
						vres = finalWord.substring(next === '@' ? 2 : 1);
						globalExport = globalExportRgxp.exec(vres);

						// Супер глобальная переменная внутри with
						if (next === '@') {
							vres = 'Snakeskin.Vars[\'' + globalExport[1] + '\']' + globalExport[2];

						} else {
							vres = vars[vres] || vres;
						}

					// Супер глобальная переменная вне with
					} else {
						globalExport = globalExportRgxp.exec(finalWord.substring(next === '@' ? 2 : 1));
						vres = 'Snakeskin.Vars[\'' + globalExport[1] + '\']' + globalExport[2];
					}

				} else {
					let rfWord = finalWord.replace(modRgxp, '');
					if (canParse && useWith) {
						let num = null;

						// Уточнение scope
						if (el === '#') {
							num = strongModRgxp.exec(finalWord);
							num = num ? num[1] : 1;
							num++;
						}

						let first = scope[0];
						vres = first;

						scope[0] = vars[scope[0]] || scope[0];
						scope.push(rfWord);

						let rnum = num = num ? scope.length - num : num,
							length = scope.length;

						for (let j = 1; j < length; j++) {
							num = num ? num - 1 : num;

							if (num === null || num > 0) {
								vres += '.' + scope[j];
								continue;
							}

							if (j === length - 1) {
								vres = (rnum > 0 ? vres + '.' : '') + scope[j];
							}
						}

						scope.pop();
						scope[0] = first;

					} else {
						vres = canParse ? vars[rfWord] || rfWord : rfWord;
					}
				}

				// Данное слово является составным системным,
				// т.е. пропускаем его и следующее за ним
				if (comboBlackWordList[finalWord]) {
					posNWord = 2;

				} else if (canParse && (!opt_sys || opt_isys)) {
					vres = 'Snakeskin.Filters.undef(' + vres + ')';
				}

				wordAddEnd += vres.length - word.length;
				nword = false;

				if (filterStart) {
					filter[filter.length - 1] += vres;
					rvFilter[filter.length - 1] += word;
					filterAddEnd += vres.length - word.length;

				} else {
					res = res.substring(0, i + uadd) + vres + res.substring(i + word.length + uadd);
				}

				// Дело сделано, теперь с чистой совестью матаем на позицию:
				// за один символ до конца слова
				i += word.length - 2;
				breakNum = 1;

				continue;

			// Возможно, скоро начнётся новое слово,
			// для которого можно посчитать scope
			} else if (newWordRgxp.test(el)) {
				nword = true;

				if (posNWord > 0) {
					posNWord--;
				}
			}

			if (!filterStart) {
				if (el === ')') {
					// Закрылась скобка, а последующие 2 символа не являются фильтром
					if (next !== '|' || !filterRgxp.test(nnext)) {
						if (pCount) {
							pCount--;
						}

						pContent.shift();
						continue;

					} else {
						deepFilter = true;
					}
				}

			// Составление тела фильтра
			} else if (el !== ')' || pCountFilter) {
				let last = filter.length - 1;

				filter[last] += el;
				rvFilter[last] += el;
			}
		}

		isFilter = el === '|';
		if (breakNum) {
			breakNum--;
		}

		if (filterStart && ((el === ')' && !pCountFilter) || i === commandLength - 1)) {
			let pos = pContent[0];

			let fadd = wordAddEnd - filterAddEnd + addition,
				fbody = res.substring(pos[0] + (pCount ? addition : 0), pos[1] + fadd);

			let arr = [];
			for (let j = 0; j < filter.length; j++) {
				if (filter[j] !== '!html') {
					arr.push(filter[j]);

				} else if (!pCount) {
					unEscape = true;
				}
			}

			filter = arr;
			let resTmp = fbody;

			for (let j = 0; j < filter.length; j++) {
				let params = filter[j].split(' ');
				let input = params.slice(1).join('').trim();

				resTmp = '($_ = Snakeskin.Filters[\'' + params.shift() + '\']' +
					(deepFilter || !pCount ? '(' : '') +
					resTmp +
					(input ? ',' + input : '') +
					(deepFilter || !pCount ? ')' : '') +
				')';
			}

			let fstr = rvFilter.join().length + 1;
			res = pCount ?

				res.substring(0, pos[0] + addition) +
					resTmp +
					res.substring(pos[1] + fadd + fstr) :

				resTmp;

			pContent.shift();

			filter = [];
			rvFilter = [];

			filterStart = false;

			if (pCount) {
				pCount--;
				deepFilter = false;
			}

			wordAddEnd += resTmp.length - fbody.length - fstr;

			if (!pCount) {
				addition += wordAddEnd - filterAddEnd;

				wordAddEnd = 0;
				filterAddEnd = 0;
			}
		}

		if (el === ')' && pCountFilter) {
			pCountFilter--;

			let last = filter.length - 1;
			let cache = filter[last];

			filter[last] = this.prepareOutput(cache, true, null, true);

			wordAddEnd += filter[last].length - cache.length;
			filterAddEnd += filter[last].length - cache.length;
		}

		// Через 2 итерации начнётся фильтр
		if (next === '|' && filterRgxp.test(nnext)) {
			nword = false;

			if (!filterStart) {
				if (pCount) {
					pContent[0].push(i + 1);

				} else {
					pContent.push([0, i + 1]);
				}
			}

			filterStart = true;
			if (!pCountFilter) {
				filter.push(nnext);
				rvFilter.push(nnext);
				i += 2;
			}
		}
	}

	return (!unEscape && !opt_sys ? 'Snakeskin.Filters.html(' : '') + res + (!unEscape && !opt_sys ? ')' : '');
};