# Snakeskin

Snakeskin -- компилятор блочных шаблонов. Поддерживает работу на сервере (node.js), а также на клиенте (в браузере).

## Области декларации шаблонов

Шаблоны можно описывать в файлах с расширением `.cc` или же в блоках `<script type="text/x-snakeskin-template">...</script>` (если нужна live компиляция шаблона, например, для отладки). В одной области может быть объявлено неограниченное количество шаблонов.


## Синтаксис блоков

Управляющие конструкции шаблонизатора размещаются между `{` и `}`.

## Параметры

Каждый шаблон может принимать параметры. Все принимаемые параметры должны быть описаны в теге `{{param name}}` или со значением по-умолчанию `{{param name = "value"}}`. Значением может быть любое выражение.

Необъявленные параметры шаблону передавать бесполезно, они будут игнорироваться.

Отсутствие глобальных данных в данный момент является осознанной жертвой в пользу очевидности использования шаблона (достаточно взглянуть на начало шаблона, чтобы узнать, какие данные ему необходимо и достаточно передать) и уменьшению связности в приложении (фактически можно скопировать всю папку с шаблонами и, не задумываясь, использовать в другом проекте, все нужные и только нужные шаблоны подключаться автоматически и не потребуют каких-либо неожиданных данных).

## Рендер внешнего шаблона

Блок `{{render tpl-name param1=i+5 param2="string"}}` вставит вместо себя вызов шаблона tpl-name и передаст ему параметры `param1` и  `param2`, которые, как сказано выше, должны быть явно описаны в шаблоне tpl-name. В параметре можно передать любое выражение.

## Переменные внутри шаблона

Внутри шаблона можно создавать переменные, в частности, они нужны для наследования.

Краткий синтаксис присваивания значения `{{set var-name=<expression>}}`, где expression -- любое выражение.
Многострочный синтаксис `{{set var-name}}<Содержимое с другими управляющими конструкциями>{{/set}}`.

## Наименование переменных и параметров

Все имена имеют стиль `foo-bar-baz`.

## Наследование шаблонов

Пусть шаблон A наследует шаблон Б. Наследование заключается в том, что после выполнения шаблона А все его переменные передаются параметрами в шаблон Б, после чего возвращается результат выполнения шаблона Б (который может наследовать дургой шаблон В).

Например, base.botex просто выводит заголовок на страницу

    {{param title}}
    <title>{{=title}}</title>

counter.botex принимает номер посетителя и выводит его в заголовке

    {{param count = 0}}
    {{extends base}}
    {{set title}}Вы {{=count}}-й посетитель.{{/set}}

counter5.botex не принимает никаких параметров, а всегда пишет, что вы 5-й посетитель.

    {{extends counter}}
    {{set count=5}}

## Вывод переменных

Для вывода переменной или выражения с экранизацией HTML используется `{{=var-name}}`, без экранизации `{{=& i + 5}}`.

## Выражения

Выражения состоят из переменных и литералов (число, строка, массив, хэш), объеденённых операциями ===, !==, ==, !=, >=, <=, &&, ||, <, >, *, /, %, +, -. Чтобы минус не конфликтовал с минусом в названии переменной, его нужно окружать пробелами. Хотя любую бинарную операцию нужно окружать пробелами. Для доступа к свойствам объекта используется JS-style, т.е. точка.

## Массивы

    {{set array=[1, 2, 3]}}
    {{set array = [
        "string 1"
        "string 2"
        "string 3"
    ]}}

В многострочном синтаксисе запятые необязательны.

## Объекты

    {{set object={a: 1, b: 2}}}
    {{set object={
        a: "string1"
        b: "string2"
    }}}

## Условный оператор

    {{if <expression>}}...{{/if}}
    {{if <expression>}}...{{else}}...{{/if}}

## Краткий условный оператор

Создан в первую очередь для удобного добавления css-классов в зависимости от параметров. Состоит из блока {{? <expression>}}. Если `expression` истинно, то пропустив пробелы, выведутся все последующие символы из набора `[a-zA-Z0-9_-]`. Например

    {{param end}}
    <div class="block {{? end}} block_end"></div>

## Итератор по массивам и хэшам

Похож на PHP-шный.

    {{foreach array as item}}
        {{=item}}
    {{/foreach}}
    {{foreach object as key => item}}
        {{=key}}
        {{=item}}
    {{/foreach}}

## Как и что компилировать

Допустим есть проект в папке /path/to/project. В нём в папке tpl-src лежат файлы *.botex, в папке templates лежат скомпилированные шаблоны для NodeJS, в папке css-src лежат скомпилированные css-файлы. Создаём в папке проекта файл .botex с содержимым

    src = tpl-src
    nodejs = templates
    css = css-src

После чего из папки, в которой лежит файл .botex запускаем компиляцию

    node /path/to/botex

Чтобы не компилировать руками после каждого изменения, можно добавить ключик --watch, тогда botex будет следить за директорией и компилировать заново изменившиеся файлы.